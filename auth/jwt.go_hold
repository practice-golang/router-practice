package auth

import (
	"crypto/rand"
	"crypto/rsa"
	"fmt"
	"log"

	"github.com/lestrrat-go/jwx/jwa"
	"github.com/lestrrat-go/jwx/jwk"
	"github.com/lestrrat-go/jwx/jwt"
)

var Secret string = "secret"
var Alg jwa.SignatureAlgorithm = jwa.RS256
var KeySET jwk.Set
var RealKey jwk.Key

// GenerateKey - 키 생성
func GenerateKey() {
	log.Println("alg/key:", Alg, Secret)

	privKey, err := rsa.GenerateKey(rand.Reader, 2048)
	if err != nil {
		log.Printf("failed to generate private key: %s\n", err)
		return
	}

	pubKey, err := jwk.New(privKey.PublicKey)
	if err != nil {
		fmt.Printf("failed to create JWK: %s\n", err)
		return
	}

	pubKey.Set(jwk.AlgorithmKey, Alg)
	pubKey.Set(jwk.KeyIDKey, Secret)

	bogusKey := jwk.NewSymmetricKey()
	bogusKey.Set(jwk.AlgorithmKey, jwa.NoSignature)
	bogusKey.Set(jwk.KeyIDKey, "otherkey")

	KeySET = jwk.NewSet()
	KeySET.Add(pubKey)
	KeySET.Add(bogusKey)

	RealKey, err = jwk.New(privKey)
	if err != nil {
		log.Printf("failed to create JWK: %s\n", err)
		return
	}

	RealKey.Set(jwk.KeyIDKey, Secret)
	RealKey.Set(jwk.AlgorithmKey, Alg)
}

// GenerateToken - 토큰 생성
func GenerateToken() (string, error) {
	token := jwt.New()
	token.Set(`foo`, `bar`)
	token.Set(`kim`, `chi`)
	signed, err := jwt.Sign(token, Alg, RealKey)
	if err != nil {
		log.Printf("failed to generate signed payload: %s\n", err)
		return "", err
	}

	result := string(signed)

	return result, err
}

// ParseToken - 토큰 파싱
func ParseToken(payloadSTR string) (jwt.Token, error) {
	payload := []byte(payloadSTR)

	token, err := jwt.Parse(
		payload,
		jwt.WithKeySet(KeySET),
	)
	if err != nil {
		log.Printf("failed to parse payload: %s\n", err)
		return nil, err
	}

	kim, valid := token.Get("foo")
	log.Println(kim, valid, token.Expiration())

	return token, err
}
